/**
 * @file supervisor.c
 * @author Domenic Melcher <e12220857@student.tuwien.ac.at>
 * @date 12.11.2023
 *
 * @brief Supervisor process managing shared memory for solutions
 *
 * The supervisor process oversees the shared memory containing solutions
 * generated by other processes (generators). It initializes, manages, and
 * retrieves solutions from shared memory, maintaining synchronization and
 * handling shutdown signals.
 *
 * Usage:
 * supervisor [-n limit] [-w delay] [-p]
 *
 * Options:
 *   -n limit    Maximum number of solutions to process
 *   -w delay    Delay in seconds before starting to process solutions
 *   -p          Flag for visualization (true/false)
 */

#include <assert.h>
#include <semaphore.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "circular_buffer.h"
#include "circular_buffer_helper.h"
#include "parser.h"
#include "shared_memory.h"

/**
 * @brief Usage information for the supervisor program.
 */
static char *USAGE = "SYNOPSIS\n\tsupervisor [-n limit] [-w delay] [-p]\n";

shared_memory_t shared_memory;     // Shared memory structure
volatile bool in_shutdown = false; // Signal for shutdown

/**
 * @brief Signal handler function for handling SIGINT.
 *
 * @param signal The signal received by the handler.
 */
void handle_shutdown(int signal) {
  sem_post(shared_memory.semaphore_in_shutdown);

  in_shutdown = true;
}

/**
 * @struct arguments_t
 * @brief Structure to hold command-line arguments.
 */
typedef struct {
  int limit;   /**< Integer value for limit how many solutions should be
                  considered for evaluating the graph */
  int delay;   /**< Integer value for delay before receiving any solutions */
  bool flag_p; /**< Flag indicating 'p' presence in arguments. */
} arguments_t;

/**
 * @brief Initialize argument structure with default values and read values from
 * argv.
 *
 * @param arguments Pointer to the arguments_t structure to be initialized.
 * @param argc Number of command-line arguments.
 * @param argv Command-line arguments as an array of strings.
 * @return Returns 0 on success, -1 on encountering an error.
 */
int arguments_init(arguments_t *arguments, int argc, char **argv) {
  // ? Ignore
  arguments->flag_p = false;

  arguments->limit = -1;
  arguments->delay = 0;

  int opt, encountered_flag_p = 0, encountered_limit = 0, encountered_delay = 0;

  while ((opt = getopt(argc, argv, "n:w:p")) != -1) {
    switch (opt) {
    case 'n':
      if (encountered_limit > 0) {
        return -1;
      }

      if (p_parse_as_int(optarg, &arguments->limit) < 0) {
        return -1;
      }

      encountered_limit += 1;

      break;
    case 'w':
      if (encountered_delay > 0) {
        return -1;
      }

      if (p_parse_as_int(optarg, &arguments->delay) < 0) {
        return -1;
      }

      encountered_delay += 1;

      break;
    case 'p':
      if (encountered_flag_p > 0) {
        return -1;
      }

      arguments->flag_p = true;

      encountered_flag_p += 1;

      break;
    default:
      fprintf(stderr, "Unknown arguments: '%d'", opt);
      return -1;
    }
  }

  return 0;
}

/**
 * @brief Main function for gathering solutions from the generators.
 *
 * @param argc Number of command-line arguments.
 * @param argv Command-line arguments as an array of strings.
 * @return Exit status of the program.
 */
int main(int argc, char **argv) {
  // ! The struct 'circular_buffer_t' must be smaller than 4096 bytes.
  assert(sizeof(circular_buffer_t) <= 4096);

  if (sm_open(&shared_memory, true) < 0) {
    return EXIT_FAILURE;
  };

  signal(SIGINT, handle_shutdown);

  arguments_t arguments;
  if (arguments_init(&arguments, argc, argv) < 0) {
    printf("%s", USAGE);

    sem_post(shared_memory.semaphore_in_shutdown);
    sm_close(&shared_memory, true);

    return EXIT_FAILURE;
  }

  fprintf(stderr, "limit = %d, delay = %d, visualization = %s\n",
          arguments.limit, arguments.delay,
          arguments.flag_p == true ? "true" : "false");

  sem_post(shared_memory.semaphore_buffer_mutex);

  sleep(arguments.delay);

  int solutions_encountered = 0;
  int best_3coloring = -1;
  while (in_shutdown == false) {
    sem_wait(shared_memory.semaphore_buffer_mutex);

    while (shared_memory.buffer->count > 0) {
      solutions_encountered += 1;

      edge_t *edges;
      // printf("DEBUG: new solution.\n");

      int len = cbh_read_edges(shared_memory.buffer, &edges);
      // printf("DEBUG: have it, len = %d\n", len);

      if (len < 0) {
        in_shutdown = true;

        fprintf(stderr, "Error: when reading from cb\n");

        break;
      }

      if (len == 0) {
        in_shutdown = true;

        printf("The graph is 3-colorable!\n");

        break;
      }

      if (best_3coloring == -1 || len < best_3coloring) {
        // printf("DEBUG: is better\n");

        best_3coloring = len;

        fprintf(stderr, "Solution with %d edges:", len);
        for (int i = 0; i < len; i += 1) {
          fprintf(stderr, " %d-%d", edges[i].node1, edges[i].node2);
        }
        fprintf(stderr, "\n");
      }

      // printf("DEBUG: next solution.\n");

      free(edges);
    }

    sem_post(shared_memory.semaphore_buffer_mutex);

    if (arguments.limit != -1 && solutions_encountered >= arguments.limit &&
        in_shutdown == false) {
      if (best_3coloring < 0) {
        fprintf(stderr, "Supervisor wasn't able to read a single value from a "
                        "generator\n");

        sem_post(shared_memory.semaphore_in_shutdown);

        sm_close(&shared_memory, true);

        return EXIT_FAILURE;
      }
      printf("The graph might not be 3-colorable, best solution removes %d "
             "edges.\n",
             best_3coloring);

      break;
    }

    // sleep for 50ms, so that other generators can have the opportunity to
    // lock the mutex
    usleep(50);
  }

  fprintf(stderr, "Shutdown ...\n");

  sem_post(shared_memory.semaphore_in_shutdown);

  sm_close(&shared_memory, true);

  return EXIT_SUCCESS;
}
